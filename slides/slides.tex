\documentclass{beamer}
\setbeamertemplate{navigation symbols}{}

\usepackage{tikz}
\usepackage{listings}

\usetheme{Warsaw}

\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}
\begin{document}
\title{LexBFS and its applications}  
\author{Guillaume Aubian}
\date{\today} 


\begin{frame}
\titlepage
\end{frame}

\begin{frame}\frametitle{Overview}\tableofcontents
\end{frame} 


\section{Graph Searches} 
\begin{frame}\frametitle{What's in a graph ?}
    \begin{block}{Graph}
	We consider non-oriented, simple and \textbf{connected} graphs
    \end{block}
    INCLUDE GRAPHS EXAMPLES AND COUNTEREXAMPLES
\end{frame}

\begin{frame}[fragile]\frametitle{Generic Search}
    \begin{lstlisting}[language = Python]
    for i in [1, ..., n]:
        if i == 1:
	    u = any vertex
	else:
	    u = any unvisited marked vertex
	visit(u)
	for v in neighbours(u):
	    mark(v)
    \end{lstlisting}
\end{frame}

\begin{frame}\frametitle{Another Characterization}
    Let's number vertices in the order they are visited.
    \begin{theorem}
        An order $\sigma$ corresponds to a Generic Search if and only if
	    
	    $$\forall a <_{\sigma} b <_{\sigma} c, ac \in E\text{ and }ab \notin E, \exists d <_{\sigma} b\text{ st }db \in E$$
    \end{theorem}
    \begin{center}
    \begin{tikzpicture}  

	\draw (0,1) arc (120:60:4) ;
	\draw [dashed] (0,1) -- (2,1);
	\draw (0,0) -- (2,1);
	\draw (0,0) node[circle, fill=blue!20]{$d$} ;
	\draw (0,1) node[circle, fill=gray!20]{$a$} ;
	\draw (2,1) node[circle, fill=gray!20]{$b$} ;
	\draw (4,1) node[circle, fill=gray!20]{$c$} ;


	\draw [dotted] (1,-0.5) -- (1,1.5);
	\draw [dotted] (3,-0.5) -- (3,1.5);
	\draw (1,-0.5) node[below]{$<$} ;
	\draw (3,-0.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}[fragile]\frametitle{DFS}
    INCLUDE GRAPH EXAMPLE
    \begin{lstlisting}[language = Python]
    for i in [1, ..., n]:
        if i == 1:
	    u = any vertex
	else:
	    u = any unvisited vertex w/ max label
	visit(u)
	for v in neighbours(u):
	    label[v] = i
    \end{lstlisting}
\end{frame}

\begin{frame}\frametitle{Another Characterization}
    \begin{theorem}
        An order $\sigma$ corresponds to a DFS if and only if
	    
	    $$\forall a <_{\sigma} b <_{\sigma} c, ac \in E\text{ and }ab \notin E, \exists a <_{\sigma} d <_{\sigma} b\text{ st }db \in E$$
    \end{theorem}
    \begin{center}
    \begin{tikzpicture}
	\draw (0,0) arc (120:60:6) ;
	\draw (2,0) -- (4,0);
	\draw [dashed] (0,0) arc (120:60:4) ;

	\draw (0,0) node[circle, fill=gray!20]{$a$} ;
	\draw (2,0) node[circle, fill=blue!20]{$d$} ;
	\draw (4,0) node[circle, fill=gray!20]{$b$} ;
	\draw (6,0) node[circle, fill=gray!20]{$c$} ;




	\draw [dotted] (1,-0.5) -- (1,1.5);
	\draw [dotted] (3,-0.5) -- (3,1.5);
	\draw [dotted] (5,-0.5) -- (5,1.5);

	\draw (1,-0.5) node[below]{$<$} ;
	\draw (3,-0.5) node[below]{$<$} ;
	\draw (5,-0.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}

\end{frame}


\begin{frame}[fragile]\frametitle{BFS}
    \begin{lstlisting}[language = Python]
    for i in [n, ..., 1]:
        if i == n:
	    u = any vertex
	else:
	    u = any unvisited vertex w/ max label
	visit(u)
	for v in neighbours(u):
	    if v has no label:
	        label[v] = i
    \end{lstlisting}

    INCLUDE GRAPH EXAMPLE
\end{frame}

\begin{frame}\frametitle{Another Characterization}
    \begin{theorem}
        An order $\sigma$ corresponds to a BFS if and only if
	    
	    $$\forall a <_{\sigma} b <_{\sigma} c, ac \in E\text{ and }ab \notin E, \exists d <_{\sigma} a\text{ st }db \in E$$
    \end{theorem}

    \begin{center}
    \begin{tikzpicture}
	\draw (0,0) arc (120:60:4) ;
	\draw (2,0) arc (120:60:4) ;
	\draw [dashed] (2,0) -- (4,0);

	\draw (0,0) node[circle, fill=blue!20]{$d$} ;
	\draw (2,0) node[circle, fill=gray!20]{$a$} ;
	\draw (4,0) node[circle, fill=gray!20]{$b$} ;
	\draw (6,0) node[circle, fill=gray!20]{$c$} ;

	\draw [dotted] (1,-0.5) -- (1,1.5);
	\draw [dotted] (3,-0.5) -- (3,1.5);
	\draw [dotted] (5,-0.5) -- (5,1.5);

	\draw (1,-0.5) node[below]{$<$} ;
	\draw (3,-0.5) node[below]{$<$} ;
	\draw (5,-0.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}

\end{frame}

\begin{frame}[fragile]\frametitle{Let's rewrite BFS}
    \begin{lstlisting}[language = Python]
    for i in [n, ..., 1]:
        if i == n:
	    u = any vertex
	else:
	    u = any unvisited vertex
	        w/ max first element of label
	visit(u)
	for v in neighbours(u):
	    label[v].append(i)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Here is LexBFS}
    \begin{lstlisting}[language = Python]
    for i in [n, ..., 1]:
        if i == n:
	    u = any vertex
	else:
	    u = any unvisited vertex
	        w/ max lexicographical label
	visit(u)
	for v in neighbours(u):
	    label[v].append(i)
    \end{lstlisting}

	
    INCLUDE GRAPH EXAMPLE
\end{frame}

\begin{frame}\frametitle{Another Characterization}
    \begin{theorem}
        An order $\sigma$ corresponds to a LexBFS if and only if
	    
	    $$\forall a <_{\sigma} b <_{\sigma} c, ac \in E\text{ and }ab \notin E, \exists d <_{\sigma} a\text{ st }db \in E\text{ and }dc \notin E$$
	 
    \end{theorem}

    \begin{center}
    \begin{tikzpicture}
	\draw (0,0) arc (120:60:4) ;
	\draw (2,0) arc (120:60:4) ;
	\draw [dashed] (2,0) -- (4,0);
	\draw [dashed] (0,0) arc (120:60:6) ;

	\draw (0,0) node[circle, fill=blue!20]{$d$} ;
	\draw (2,0) node[circle, fill=gray!20]{$a$} ;
	\draw (4,0) node[circle, fill=gray!20]{$b$} ;
	\draw (6,0) node[circle, fill=gray!20]{$c$} ;


	\draw [dotted] (1,-0.5) -- (1,1.5);
	\draw [dotted] (3,-0.5) -- (3,1.5);
	\draw [dotted] (5,-0.5) -- (5,1.5);

	\draw (1,-0.5) node[below]{$<$} ;
	\draw (3,-0.5) node[below]{$<$} ;
	\draw (5,-0.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}\frametitle{Another Characterization}
    Iterating on [1, ..., n] and prepending, we obtain LexDFS
    \begin{theorem}
        An order $\sigma$ corresponds to a LexDFS if and only if
	    
	    $$\forall a <_{\sigma} b <_{\sigma} c, ac \in E, ab \notin E, \exists a <_{\sigma} d <_{\sigma} b\text{ st }db \in E, dc \notin E$$
    \end{theorem}
    \begin{center}
    \begin{tikzpicture}
	\draw (0,0) arc (120:60:6) ;
	\draw (2,0) -- (4,0);
	\draw [dashed] (0,0) arc (120:60:4) ;
	\draw [dashed] (2,0) arc (120:60:4) ;

	\draw (0,0) node[circle, fill=gray!20]{$a$} ;
	\draw (2,0) node[circle, fill=blue!20]{$d$} ;
	\draw (4,0) node[circle, fill=gray!20]{$b$} ;
	\draw (6,0) node[circle, fill=gray!20]{$c$} ;

	\draw [dotted] (1,-0.5) -- (1,1.5);
	\draw [dotted] (3,-0.5) -- (3,1.5);
	\draw [dotted] (5,-0.5) -- (5,1.5);

	\draw (1,-0.5) node[below]{$<$} ;
	\draw (3,-0.5) node[below]{$<$} ;
	\draw (5,-0.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}
\end{frame}

\begin{frame}\frametitle{How to implement LexBFS: Pivoting}
    \only<1>{Let's order vertices by label :}
    \only<2>{We remove one of the maximum vertex :}
    \only<3>{Now, we split each bucket}
    \only<1-2>{
    \begin{center}
    \begin{tikzpicture}
	\draw (0,-2) node[circle, fill=black]{} ;
	\draw (0,0) node[circle, fill=black]{} ;
	\only<2>{\draw (0,0) node[circle, fill=purple]{} ;}
	\draw (0,2) node[circle, fill=black]{} ;
	\only<2>{\draw (0,2) node[circle, fill=purple]{} ;}

	\draw (2,-1) node[circle, fill=black]{} ;
	\draw (2,1) node[circle, fill=black]{} ;
	\only<2>{\draw (2,1) node[circle, fill=purple]{} ;}

	\draw (4,0) node[circle, fill=black]{} ;

	\draw (6,-2) node[circle, fill=black]{} ;
	\draw (6,0) node[circle, fill=black]{} ;
	\draw (6,2) node[circle, fill=black]{} ;
	\only<2>{\draw (6,2) node[circle, fill=purple]{} ;}

	\only<1>{\draw (8,0) node[circle, fill=black]{} ;}



	\draw [dotted] (1,-2.5) -- (1,2.5);
	\draw (1,-2.5) node[below]{$<$} ;

	\draw [dotted] (3,-2.5) -- (3,2.5);
	\draw (3,-2.5) node[below]{$<$} ;

	\draw [dotted] (5,-2.5) -- (5,2.5);
	\draw (5,-2.5) node[below]{$<$} ;

	\only<1>{\draw [dotted] (7,-2.5) -- (7,2.5);}
	\only<1>{\draw (7,-2.5) node[below]{$<$} ;}
    \end{tikzpicture}
    \end{center}
    }
    \only<3>{
    \begin{center}
	    \begin{tikzpicture}[scale = 0.8]
	\draw (0,0) node[circle, fill=black]{} ;

	\draw (2,-1) node[circle, fill=purple]{} ;
	\draw (2,1) node[circle, fill=purple]{} ;

	\draw (4,0) node[circle, fill=black]{} ;

	\draw (6,0) node[circle, fill=purple]{} ;

	\draw (8,0) node[circle, fill=black]{} ;

	\draw (10,-1) node[circle, fill=black]{} ;
	\draw (10,1) node[circle, fill=black]{} ;

	\draw (12,0) node[circle, fill=purple]{} ;




	\draw [dotted] (1,-2.5) -- (1,2.5);
	\draw (1,-2.5) node[below]{$<$} ;

	\draw [dotted] (3,-2.5) -- (3,2.5);
	\draw (3,-2.5) node[below]{$<$} ;

	\draw [dotted] (5,-2.5) -- (5,2.5);
	\draw (5,-2.5) node[below]{$<$} ;

	\draw [dotted] (7,-2.5) -- (7,2.5);
	\draw (7,-2.5) node[below]{$<$} ;

	\draw [dotted] (9,-2.5) -- (9,2.5);
	\draw (9,-2.5) node[below]{$<$} ;

	\draw [dotted] (11,-2.5) -- (11,2.5);
	\draw (11,-2.5) node[below]{$<$} ;
    \end{tikzpicture}
    \end{center}

    }

\end{frame}

\begin{frame}\frametitle{Data structure for pivoting}
\begin{itemize}
    \item Vertices in a doubly linked list
    \item Pointer from each vertex to its class
    \item Pointers from each class to its first and last vertex
\end{itemize}
\end{frama} 

\end{document}
